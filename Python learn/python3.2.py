#学习了列表、元组和字符串，发现它们之间有很多的共同点：
#1.都可以通过索引获得每一个字符
#2.第一个元素的索引值都是 0
#3.都可以通过切片的方法获取一个范围
#4.都有很多共同的运算符
#python将列表、元组和字符串统称为序列，根据是否能被修改这些特征我们可以将序列分为可变序列和不可变序列，列表就是一个典型的可变序列，而元组和字符串则是不可变序列。

#1.加减乘除里只有加号和乘号这两个可以在序列上使用，序列的加法表示拼接，乘法表示进行重复。
#对于增量赋值也是可以的，不过需要注意一点
s=[1,2,3]
print(id(s))
s *=2
print(s)
print(id(s))
#s*=2，得到新的s[1,2,3,1,2,3]，然后在输入id(s)会发现两次调用id(s)的结果都是一样的
#python中每一个对象都有三个基本属性，第一个是唯一标志，第二个和第三个就是类型和值，这个唯一标志是随着对象创建的时候它就有的，它是不可以被修改的，也不会有和它一样的数值

#若对象为不可变序列元组，那就不一样了
t=(1,2,3)
print(id(t))
t *=2
print(t)
print(id(t))
#虽然两个t的变量名一样，但可以看到不仅t的内容变了，而且t的唯一标志也发生了改变。

#2.is 和 is not
#python 专门搞了两个运算符is和is not，它们于检测对象的id值是否相等
#对于字符串来说，字符串一样的话，它们就是同一个对象，但对于列表来说，虽然它们的值一样但它们却是不同的对象。
#因为字符串是不可变的，列表是可变的。

#3. in 和 not in
#in 和 not in判断的则是包含问题。in运算符是判断某个元素是否包含在序列中，而not in呢，则恰恰相反

#4.del  del 语句用于删除一个或多个指定的对象：
x='dxy'
y=[1,2,3]
del x,y
#此时输出x,y会报错

#删除可变序列中的指定元素
x=[1,2,3,4,5]
del x[1:4]  #左闭右开
print(x)
y=[1,2,3,4,5]
y[1:4]=[]
print(y)
'''
是将一个空列表复制给一个切片区域，它相当于是执行了两个步骤的操作，
第一步是将赋值号左边指定的这个切片区的内容给清除，
第二个步骤就是将赋值号右侧的可迭代对象的内容插入到左侧刚刚被清空的位置里边
'''
#del 还可以完成切片做不了的事
x=[1,2,3,4,5]
del x[::2]
print(x)
#[2,4]
y=[1,2,3,4,5]
#y[::2]=[]
#输出y会报错
#因为切片的删除实则是两个过程，清除和赋值，这里切片的清除有两个位置，所以也需要赋值两个位置的值才可以，但这里相当于就赋值了一个值，所以错误

#x.clear()和 del x[:]的区别


#5.与序列相关的函数
#5.1列表、元组和字符串相互转换 
#要将一个可迭代对象转换成列表非常简单，直接调用 list()函数就可以了，同样将一个可迭代对象转换成元组直接调用tuple()函数，将可迭代对象转换成字符串直接使用str()函数：
#5.2 min()& max() 可传入可迭代对象（列表，字符串）或多个参数min(1,2,4,5)
#当这两个函数里传入的是字符串时，它比较的是字符串中每个字符的编码值。
s=[]
#min(s)
'''
此时输出则会报错
从上面这段代码中可以看出当传入一段空的字符串时，python 会报错，不过这里可以设置一个叫做default的参数，
这时候它会将default参数指定的内容输出，当前面不是空的序列，可以进行比较时，default将不再起作用
'''
s=[]
print(min(s,default='什么都没有，无法查找最小值'))

#5.3 len() &sum()
#len函数有最大可承受范围，最大值为2的电脑位数的次方减1
#sum()函数中有一个start的参数，它可以从指定的数开始加，strat=100，即从100开始加
s=[1,0,0,8,6]
print(sum(s))
print(sum(s,start=100))

#5.4  sorted() & reversed() 
#列表里边有一个 sort()方法，用于对列表的元素进行原地排序，那么这个 sorted()函数可以说是它的亲家，不仅长的像，而且功能和参数也类似
s=[1,2,3,0,6]
print(sorted(s))
print(s)
#[1,2,3,0,6]
print(s.sort())
print(s)
#[0,1,2,3,6]
#这里注意sorted()函数虽然也排序了，但是 s没有改变，而 sort()方法则是输出一个新的列表
#sorted()函数也支持 key和reverse两个参数用法呢也是跟列表的sort()方法是一样的
sorted(s,reverse=True)
t=['FishC','Apple','Book','Pen']
print(sorted(t))
print(sorted(t,key=len))
'''
key传入的是一个函数的名字，这里传入的是len()函数。key的作用是：它指定一个
干预排序算法的函数，比如这里我们指定为 len()函数，这里写函数没有括号，直接写上函数名就
好了，那这样呢，在排序的时候，它就会先将列表中的每个元素去自动调用一次这个 len()函数，
然后比较的是 len()函数返回后的结果，所以这个语法比较的是每个元素的长度。这里后面三个元
素自己理解的是长度一样的话就会按照原先列表里的顺序去排
'''
#sort()方法只能处理列表，sorted()函数就不一样了，它可以接受任何形式的可迭代对象作为参数

s=[1,2,5,8,0]
print(reversed(s))
#<list_reverseiterator object at 0x00000239FDB2B670>
print(list(reversed(s)))
'''
reversed()函数返回的是一串奇奇怪怪的英文，这是一段迭
代器，我们就可以使用 list()函数，
reversed()函数也可以支持任何形式的可迭代对象
'''

#all() & any() 
#all()函数是判断可迭代对象中是否所有元素的值都为真，那么 any()函数则是判断可迭代对象中是否存在某个元素的值为真、
#不为零都为真

#5.6 enumerate()  enumerate()函数用于返回一个枚举对象，它的功能就是将可迭代对象中的每个元素及从 0开始的序号共同构成一个二元组的列表
seasons=['spring','summer','fall','winter']
print(enumerate(seasons))
print(list(enumerate(seasons)))
#[(0, 'spring'), (1, 'summer'), (2, 'fall'), (3, 'winter')]
#它还有一个stat 参数，可以自定义这个序号开始的值，因为默认是从 0开始，直接用逗号隔开后，写上这个start的值即可
print(list(enumerate(seasons,10)))
#[(10, 'spring'), (11, 'summer'), (12, 'fall'), (13, 'winter')]

#5.7 zip()
#zip()函数用于创建一个聚合多个可迭代对象的迭代器。它会将作为参数传入的每个迭代对象的每个元素依次组合成元组，即第i个元组包含来自每个参数的第i个元素
x=[1,2,3]
y=[4,5,6]
print(list(zip(x,y)))
#[(1, 4), (2, 5), (3, 6)]
z=[7,8,9]
print(list(zip(x,y,z)))
#[(1, 4, 7), (2, 5, 8), (3, 6, 9)]
#若是传入参数的长度不一样结果会怎么样
z='dxyhhh'
print(list(zip(x,y,z)))
#[(1, 4, 'd'), (2, 5, 'x'), (3, 6, 'y')]
#它会以最短的参数的长度来输出，多于的就自动舍弃了。那要是我们比较重视多余的元素，我们可以使用一个叫做itertools的模块，里面有个zip_longest()的一个函数，使用这个来代替zip
import itertools
zipped=itertools.zip_longest(x,y,z)
print(list(zipped))
#[(1, 4, 'd'), (2, 5, 'x'), (3, 6, 'y'), (None, None, 'h'), (None, None, 'h'), (None, None, 'h')]
#x，y里边是没有元素的，这里它会自动填充为None

#5.8 map()  map()函数会根据提供的函数对指定的可迭代对象的每个元素进行运算，并将返回运算结果的迭代器
mapped=map(ord,'FishC')   #ord函数的作用就是将一个字符准转换成对应的编码值
print(list(mapped))
#[70, 105, 115, 104, 67]
#map()函数里的第一个参数是指定一个函数,map()函数的作用就是对随后提供的可迭代对象进行加工

#map()函数里指定的函数需要两个或多个参数
print(list(map(pow,[2,3,10],[5,2,3])))
#pow()函数，这个函数是计算次方的，它需要两个参数。
#可以看到它的结果是依次输出25，32，103它的结果就相当于这样一个语法：
print([pow(2,5),pow(3,2),pow(10,3)])

#5.9 filter()  它们的区别是 map()函数返回的是包含计算结果的迭代器，而
               #filter()返回的是计算结果为真的元素构成的迭代器


#6.迭代器和可迭代对象
#一个迭代器肯定是一个可迭代对象。它们最大的区别是可迭代对象可以重复使用而迭代器则是一次性的
mapped=map(ord,'FishC')
for each in mapped:
    print(each)
print(list(mapped))
#此时结果为 []  说明迭代器只能用一次

#可迭代对象也是有办法可以使它变成迭代器的，这里需要引入一个新的函数iter()
x=[1,2,3,4,5]
y=iter(x)
print(type(x))
print(type(y))
#x是一个列表，而y是一个列表的迭代器
